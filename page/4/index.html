<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://t51645.github.io/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://t51645.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-codeforces 817D Imbalanced Array " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/codeforces 817D Imbalanced Array /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/codeforces 817D Imbalanced Array /">codeforces 817D Imbalanced Array</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>题目链接：</p>
<p><a href="http://codeforces.com/contest/817/problem/D" target="_blank" rel="noopener"> http://codeforces.com/contest/817/problem/D
</a></p>
<p>题意：</p>
<p>给出一组数，求所有连续子串的最大值与最小值差的和</p>
<p>题解：</p>
<p>从每个数可作为最大值被计算次数Maxki和最小值计算次数Minki入手，答案就是sum(Maxki<em>num[i]-Minki</em>num[i])</p>
<p>那么如何计算Maxki和Minki呢？</p>
<p>首先假设这个数num[i]是连续子串的第一位数，那么我们向右查询到第一个大于等于它的数的下标为Maxridx，则以这个数为第一位数的连续子串中这个数作为最大<br>值被计算了Maxridx-i+1次，同样作为最小值可以采取同样的方法这个数被计算了Minridx-i+1次。这里的查找可以采用二分+RMQ因为最大值和最小值<br>都有单调性。</p>
<p>接下来再从这个数不是连续子串的第一位开始考虑：</p>
<p>因为第i个数前面也可能存在比它大的数，所以可以从第i个数向左查找到第一个大于等于它的数的下标Maxlidx，则这个数作为最大值被计算了(i-Maxlidx+<br>1)*(Maxridx-i+1)次，</p>
<p>作为最小值被计算了(i-Minlidx+1)*(Minridx-i+1)次。这个向左查找最值的方法采用单调栈的方法。</p>
<p>所以最后第i个数对答案的贡献为(i-Maxlidx+1)<em>(Maxridx-i+1)</em>num[i]-(i-Minlidx+1)<em>(Minridx-i+1)</em><br>num[i]</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define inf 0x3f3f3f3f
#define ll long long
#define ull unsigned long long
const int mod = 1e4+7;
const ll INF = 2e18;
typedef pair&lt;int, int&gt;P;
const double eps = 1e-6;
const int maxn = 1e6+5;

int n;
int num[maxn];
int minsum[maxn][20];
int maxsum[maxn][20];
void init_RMQ(int n)
{
    for(int i=1;i&lt;=n;i++)
        maxsum[i][0] = minsum[i][0] = num[i];
    int k = log2(1.0*n);
    for(int j=1;j&lt;=k;j++) {
        for(int i=1;i&lt;=n;i++) {
            if(i+(1&lt;&lt;j)-1&lt;=n) {
                maxsum[i][j] = max(maxsum[i][j-1], maxsum[i+(1&lt;&lt;(j-1))][j-1]);
                minsum[i][j] = min(minsum[i][j-1], minsum[i+(1&lt;&lt;(j-1))][j-1]);
            }
        }
    }
}
int getMax(int i,int j)
{
    int k = (int)log2(1.0*(j-i+1));
    return max(maxsum[i][k], maxsum[j-(1&lt;&lt;k)+1][k]);
}
int getMin(int i,int j)
{
    int k = (int)log2(1.0*(j-i+1));
    return min(minsum[i][k], minsum[j-(1&lt;&lt;k)+1][k]);
}
int bsmn(int L)
{
    int l = L+1;
    int r = n;
    int ans = L;
    while(l &lt;= r) {
        int mid = (l+r)&gt;&gt;1;
        if(getMin(L+1, mid) &gt; num[L]) {
            ans = max(ans, mid);
            l = mid + 1;
        }
        else {
            r = mid - 1;
        }
    }
    return ans;
}
int bsmx(int L)
{
    int l = L+1;
    int r = n;
    int ans = L;
    while(l &lt;= r) {
        int mid = (l+r)&gt;&gt;1;
        if(getMax(L+1, mid) &lt; num[L]) {
            ans = max(ans, mid);
            l = mid + 1;
        }
        else {
            r = mid - 1;
        }
    }
    return ans;
}
int main()
{
    cin &gt;&gt; n;
    for(int i=1; i&lt;=n; i++) {
        scanf(&quot;%d&quot;, &amp;num[i]);
    }
    init_RMQ(n);
    ll ans = 0;
    int mxidx = bsmx(1);
    int mnidx = bsmn(1);
    ans += 1ll*mxidx*num[1];
    ans -= 1ll*mnidx*num[1];
    stack&lt;P&gt;mx;
    stack&lt;P&gt;mn;
    mx.push(P(num[1], 1));
    mn.push(P(num[1], 1));
    for(int i=2; i&lt;=n; i++) {
        mxidx = bsmx(i);
        mnidx = bsmn(i);
        int mxk = i;
        int mnk = i;
        while(mx.size() &amp;&amp; mx.top().first &lt;= num[i]) {
            mxk = mx.top().second;
            mx.pop();
        }
        mx.push(P(num[i], mxk));
        while(mn.size() &amp;&amp; mn.top().first &gt;= num[i]) {
            mnk = mn.top().second;
            mn.pop();
        }
        mn.push(P(num[i], mnk));
        //printf(&quot;%d %d %d %d\n&quot;, i-mxk+1, i-mnk+1, mxidx-i+1, mnidx-i+1);
        ans += 1ll*(i-mxk+1)*num[i]*(mxidx-i+1);
        ans -= 1ll*(i-mnk+1)*num[i]*(mnidx-i+1);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/codeforces 817D Imbalanced Array /" data-id="cjttuf872001le8v3hp1ysubh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hdu 2196 【树形DP】 " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/hdu 2196 【树形DP】 /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/hdu 2196 【树形DP】 /">hdu 2196 【树形DP】</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=2196" target="_blank" rel="noopener">http://acm.split.hdu.edu.cn/showproblem.php?pid=2196</a></p>
<p>题意：求树上每个点与另一点的最远距离</p>
<p>题解：</p>
<p>设dp[i][0]为第i个结点的子树最远叶子结点距离，dp[i][1]为第i个结点的子树次远叶子结点距离，dp[i][2]为第i个结点通过父结点能到的最远距<br>离。  </p>
<p>两次dfs，第一次保存dp[i][0]与dp[i][1]</p>
<p>第二次求dp[i][2]，要注意求dp[i][2]时要判断父节点的最远叶子结点是否在i结点的子树上，如果在则dp[i][2] =<br>max(dp[fa][2], dp[fa][1])+c否则dp[i][2] = max(dp[fa][2], dp[fa][0])+c</p>
<pre><code>#pragma comment(linker, &quot;/STACK:102400000,102400000&quot;)
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;time.h&gt;
#include&lt;sstream&gt;
using namespace std;
#define MAX_N 50005
#define inf 0x7f7f7f7f
#define LL long long
#define ull unsigned long long
const LL INF = 1e18;
//const double Pi = acos(-1);
const int mod = 1e4+7;
typedef pair&lt;int, int&gt;P;

vector&lt;P&gt;G[MAX_N];
int dp[MAX_N][3];
void dfs1(int u, int pre)
{
    dp[u][0] = dp[u][1] = dp[u][2] = 0;
    for(int i=0; i&lt;G[u].size(); i++) {
        int v = G[u][i].first;
        int c = G[u][i].second;
        if(v == pre)
            continue;
        dfs1(v, u);
        if(dp[v][0]+c &gt; dp[u][0]) {
            dp[u][1] = dp[u][0];
            dp[u][0] = dp[v][0]+c;
        }
        else if(dp[v][0]+c == dp[u][0]) {
            dp[u][1] = dp[u][0];
        }
        else if(dp[v][0]+c &gt; dp[u][1]) {
            dp[u][1] = dp[v][0]+c;
        }
    }
}
void dfs2(int u, int pre)
{
    for(int i=0; i&lt;G[u].size(); i++) {
        int v = G[u][i].first;
        int c = G[u][i].second;
        if(v == pre)
            continue;
        if(dp[u][0] == dp[v][0]+c)
            dp[v][2] = max(dp[u][2], dp[u][1])+c;
        else
            dp[v][2] = max(dp[u][2], dp[u][0])+c;
        dfs2(v, u);
    }
}
int main()
{
    int n;
    while(cin &gt;&gt; n) {
        for(int i=1; i&lt;=n; i++)
            G[i].clear();
        for(int i=2; i&lt;=n; i++) {
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            G[i].push_back(P(a, b));
            G[a].push_back(P(i, b));
        }
        dfs1(1, 0);
        dfs2(1, 0);
        for(int i=1; i&lt;=n; i++) {
            printf(&quot;%d\n&quot;, max(dp[i][0], dp[i][2]));
        }
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/hdu 2196 【树形DP】 /" data-id="cjttuf873001ne8v3f6mumdzh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hdu 4515 【树的直径】 " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/hdu 4515 【树的直径】 /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/hdu 4515 【树的直径】 /">hdu 4515 【树的直径】</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4514" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=4514</a>  </p>
<p>题解：</p>
<p>先用一次dfs判断是否存在环，然后再枚举树的叶子节点找最长路。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;time.h&gt;
#include&lt;sstream&gt;
using namespace std;
#define MAX_N 100005
#define inf 0x7f7f7f7f
#define LL long long
#define ull unsigned long long
const LL INF = 1e18;
const double Pi = acos(-1);
const int mod = 1e4+7;
typedef pair&lt;int, int&gt;P;

vector&lt;P&gt;G[MAX_N];
bool vis[MAX_N];
int n, m;
int mx;
int s;
void init()
{
    memset(vis, false, sizeof(vis));
}
bool dfs(int u, int pre, int sum)
{
    if(sum &gt; mx) {
        mx = sum;
        s = u;
    }
    for(int i=0; i&lt;G[u].size(); i++) {
        int v = G[u][i].first;
        int c = G[u][i].second;
        if(v == pre)
            continue;
        if(vis[v])
            return true;
        vis[v] = true;
        if(dfs(v, u, sum+c))
            return true;
        vis[v] = false;
    }
    return false;
}
int main()
{
    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) {
        init();
        for(int i=1; i&lt;=n; i++)
            G[i].clear();
        for(int i=0; i&lt;m; i++) {
            int a, b, c;
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            G[a].push_back(P(b, c));
            G[b].push_back(P(a, c));
        }
        mx = 0;
        vis[1] = true;
        if(dfs(1, 0, 0)) {
            puts(&quot;YES&quot;);
            continue;
        }
        int ans = 0;
        init();
        for(int i=1; i&lt;=n; i++) {
            mx = 0;
            if(G[i].size() &gt; 1)//如果不是叶子节点
                continue;
            init();
            vis[i] = true;
            dfs(i, 0, 0);
            ans = max(ans, mx);
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/hdu 4515 【树的直径】 /" data-id="cjttuf874001pe8v3ysvckyn0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-14届浙江省acm总结 " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/14届浙江省acm总结 /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/14届浙江省acm总结 /">14届浙江省acm总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于省赛后学校就开始了招生周放假了，放假期间一起在外面玩也没怎么碰电脑，所以总结就拖到了现在。  </p>
<p>时间过的太快了，转眼已经大二了，再过两年就毕业了，剩下给自己的时间也没有多少了。</p>
<p>回想去年，同队的两个大一队友一个已经不搞竞赛了，另外一个成了ctf的dalao，只剩下自己还在苦苦挣扎，挣扎了一年还是打了个铜。。。  </p>
<p>不管是去年还是今年的省赛都是感觉再稍微前进一点就能上升一个档次，去年是差在计算循环节，今年是E题比赛时没发挥好。</p>
<p>今年的省赛难度递增，前四题都是水题，大概有将近180支队伍写出来吧，我们队由于大四的键叔读题比较快再加上水题我平时敲的比较多，67min4题都是1A过的，但<br>是最后也止步于此了，挂机了将近4h<br><img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/cry.gif" alt="哭"> 。A完4题<br>我们大概排在28名，但是最终排在了将近60名，当时是键叔先看了E告诉我题意和大概解法，然后我琢磨了一会感觉不会，后来在纸上写了几下大概知道了规律，然后告诉了<br>键叔，然后我先敲了一会，后来莫名奇妙就让键叔敲了。。然后我在一旁看他敲，但是我比较急，看他敲的这么慢就自己上了，到这里就大概花了2h了，后来我把大致的代码写<br>好了一运行，连样例都过不了，赛后重写时觉得应该是细节没处理好。就这样我让键叔继续上去写F，然后接下来的2h就是我们俩交替的调试，不过最终我也没写出来。。然后<br>比赛最后一分钟键叔貌似写好了然后提交了一发T了，后来把输出cout改成printf再提交就已经超出比赛时间5s了。。。当时赛后我说要是能过就让他背锅<br><img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/cry.gif" alt="哭"><br>，不过最后好像还是错的。。就这样我们两个人分开写两题都没写出来。</p>
<p>赛后键叔重新写了F貌似用set瞎搞就过了，我再用比赛时的方法一写也过了E，E赛后我看网上都说是数位dp，不过我用的方法貌似不是数位dp而是找规律。</p>
<p>E题大致方法如下：</p>
<p>设输入为长整型 n 与字符串 s</p>
<p>然后将字符串s转化成长整型m  </p>
<p>设有函数f(x)为计算[0,x)共需要多少能量</p>
<p>所以最终的答案就为f(n+m)-f(m)</p>
<p>f(x)的计算方法大致如下：</p>
<p>将x转化成八位16进制数： X7X6X5X4X3X2X1X0</p>
<p>然后从高位开始进行计算，从高位开始计算是有原因的，</p>
<p>因为可以将一个8位16进制数分解成</p>
<p>X7+X6+X5+X4+X3+X2+X1+X0</p>
<p>然后当要计算f(tmp)</p>
<p>可找规律：  </p>
<p>当tmp为(00000010)16 比k低位的数中0~F16个数都被计算了1次（0~F）</p>
<p>当tmp为(00000100)16 比k低位的数中0~F16个数都被计算了32次（00~FF）</p>
<p>当tmp为(00001000)16 比k低位的数中0~F16个数都被计算了768次（000~FFF）（这个不用手写可以得到规律的。。）</p>
<p>找规律的方法的话我是从3进制数开始考虑的然后再将进制数取大判断下可不可以，最后就得到了规律：</p>
<p>16进制数中0~F16个数共被计算了 (k<em>16^k)/16 次，分子表示一共有几数 = k位</em>16^k个16进制数，分母16是平分给16个数</p>
<p>当第k位不为1的时候也有类似的规律，比如说k位为num[k]则低位数0~F被计算次数位num[k]<em>(k</em>16^k)/16，因为0~F<br>16个数消耗的能量和都是固定的，所以计算第k位时低位消耗的能量和为sum<em>num[k]</em>(k*16^k)/16</p>
<p>因为低位变化时可能会导致进位，如 20 就是 2个0~F和16个0与16个1组成的6，这个计算比较简单就不讲了，</p>
<p>然后高位是不变的，把比k高的位求个和在乘一下计算次数就可以了。</p>
<p>最后第k位需要的能量为 sumN<em>16^k + sumU</em>num[k]<em>16^k + k</em>16^(k-1)<em>sum</em>num[k]</p>
<p>（num[k]为第k为数，sumN为[0,num[k])的耗能和,sumU为比k高位的数的耗能和，sum为0~F的耗能和）</p>
<p>还有一点要注意：因为给出的可能为 10 FFFFFFFF 这种会进位的所以要将数转化成9位16进制数来写，再考虑一些细节就可以了</p>
<p>代码如下：  </p>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

map&lt;char, long long&gt;mp;
long long d[16];
long long sum = 0;
long long pow16[10];
void init()
{
    for(long long i=0; i&lt;10; i++)
        mp[&apos;0&apos;+i] = i;
    for(long long i=0; i&lt;6; i++)
        mp[&apos;A&apos;+i] = 10 + i;
    d[0] = 6; d[1] = 2; d[2] = 5; d[3] = 5; d[4] = 4;
    d[5] = 5; d[6] = 6; d[7] = 3; d[8] = 7; d[9] = 6;
    d[10] = 6; d[11] = 5; d[12] = 4; d[13] = 5; d[14] = 5;
    d[15] = 4;
    for(int i=0; i&lt;16; i++)
        sum += d[i];
    pow16[0] = 1;
    for(int i=1; i&lt;10; i++)
        pow16[i] = pow16[i-1]*16;
}
long long str2long(char *s)
{
    long long ans = 0;
    for(int i=0; i&lt;8; i++) {
        ans = ans*16 + mp[s[i]];
    }
    return ans;
}
long long calc(long long n)
{
    long long num[10];
    for(int i=0; i&lt;9; i++) {
        num[i] = n%16;
        n /= 16;
    }
    long long ans = 0;
    long long pre = 0;
    if(num[8])
        ans += 8*pow16[7]*sum;
    for(long long i=7; i&gt;=0; i--) {
        long long tmp = 0;
        for(int j=0; j&lt;num[i]; j++) {
            tmp += d[j];
        }
        ans += tmp*pow16[i] + pre*num[i]*pow16[i];
        if(i)
            ans += i*pow16[i-1]*sum*num[i];
        pre += d[num[i]];
    }
    return ans;
}
int main()
{
    init();
    int T;
    cin &gt;&gt; T;
    while(T--) {
        long long n;
        char s[10];
        scanf(&quot;%lld %s&quot;, &amp;n ,s);
        long long m = str2long(s);
        n += m;
        long long disn = calc(n);
        long long dism = calc(m);
        printf(&quot;%lld\n&quot;, disn-dism);
    };
    return 0;
}

/*
5
1 89ABCDEF
2 89ABCDEF
3 89ABCDEF
4 89ABCDEF
5 89ABCDEF
*/
</code></pre><p>接下来为区域赛做准备<br><img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/struggle.gif" alt="奋斗">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/14届浙江省acm总结 /" data-id="cjttuf85v0000e8v3w4jcg633" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-poj 1745 Divisibility " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/poj 1745 Divisibility /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/poj 1745 Divisibility /">poj 1745 Divisibility</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>题目链接：</p>
<p><a href="http://poj.org/problem?id=1745" target="_blank" rel="noopener">http://poj.org/problem?id=1745</a></p>
<p>题意：</p>
<p>给出N个数a[i],在中间填上加号或减号，问能否出现一种填法使和能被K整除</p>
<p>题解：  </p>
<p>我们可以 bool dp[i][j] = true 表示前i个数的和可能出现j，再通过dp[i][j] = true 当dp[i-1][j-a[i]] =<br>true 或 dp[i-1][j+a[i]] = true，然后我们再枚举j = nk<br>(n=1,2,…)判断是否存在dp[N][nk]，但是由于每个数的绝对值最大为10000并且最多有10000个数，所以这样不可行。但是由于(a+b)<br>mod c == a mod c + b mod c 所以 dp[i][j] = true 当dp[i-1][(j-a[i])%k] = true 或<br>dp[i-1][(j+a[i])%k] = true。不过还要注意和为负数的问题。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;time.h&gt;
using namespace std;
#define MAX_N 100005
#define inf 0x3f3f3f3f
#define LL long long
#define ull unsigned long long
const LL INF = 1e18;
const int mod = 1e8+7;
typedef pair&lt;int, int&gt;P;

bool dp[10005][205];
int main()
{
    int N, K;
    cin &gt;&gt; N &gt;&gt; K;
    int x;
    dp[0][100] = true;
    for(int i=0; i&lt;N; i++) {
        scanf(&quot;%d&quot;, &amp;x);
        for(int j=-100; j&lt;=100; j++) {
            if(dp[i][j+100]) {
                dp[i+1][(j+x)%K+100] = true;
                dp[i+1][(j-x)%K+100] = true;
            }
        }
    }
    if(dp[N][100])
        puts(&quot;Divisible&quot;);
    else
        puts(&quot;Not divisible&quot;);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/poj 1745 Divisibility /" data-id="cjttuf876001te8v3p1lwgxyj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-tyvj 1505 打砖头 " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/tyvj 1505 打砖头 /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/tyvj 1505 打砖头 /">tyvj 1505 打砖头</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>题目链接：<a href="http://www.tyvj.cn/p/1505" target="_blank" rel="noopener">http://www.tyvj.cn/p/1505</a></p>
<p>原博客链接：<a href="http://www.cnblogs.com/zjerly/archive/2011/11/02/2232526.html" target="_blank" rel="noopener">http://www.cnblogs.com/zjerly/archive/2011/11/02/2232526.html</a>  </p>
<p>题解：</p>
<p>这个打砖头是很经典的题目。</p>
<p>一开始想着在题目给的形状上dp，结果发现这样的话会有三角形重合现象也就是动规有了后效性。</p>
<p>消除后效性要么转换状态，要么在状态里记录一下取数的情况。记录取数的情况，状压dp？别开玩笑了我直接搞不了。</p>
<p>那么只能转换一下，上网上看了别人的方法，把三角形倒过来了！</p>
<p>比如说样例：</p>
<p>2 2 3 4</p>
<p>8 2 7</p>
<p>2 3</p>
<p>49</p>
<p>倒过来之后——&gt;</p>
<p>4</p>
<p>3 7</p>
<p>2 2 3</p>
<p>2 8 2 49</p>
<p>那么每一点只能由左边的点转移过来，和左上角一直到上一行末尾的数转移过来。</p>
<p>如第四行第2个数可以从第三行的1，2，3个数转移过来。为什么？再回去看看题吧……</p>
<p>那么就可以开状态f[i,j,k]表示取到i,j这个位置，取了k个数的最大得分。</p>
<p>那么如果取这个数，只能是a[i,1]+a[i,2]+…+a<a href="这个预处理出来">i,j</a>+f[i-1,p,k-j]  其中p取j-1到i-1。如上述。</p>
<p>还应该注意每行都应该计算f[i,0,k]表示这一行不取数的答案。代码如下：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;time.h&gt;
using namespace std;
#define MAX_N 100005
#define inf 0x3f3f3f3f
#define LL long long
#define ull unsigned long long
const LL INF = 1e18;
const int mod = 1e8+7;
typedef pair&lt;int, int&gt;P;

int a[55][55];
int dp[55][55][505];
int n, m;
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int j=1; j&lt;=n; j++)
        for(int i=n; i&gt;=j; i--)
            scanf(&quot;%d&quot;, &amp;a[i][j]);
    memset(dp, -1, sizeof(dp));
    for(int i=0; i&lt;=n; i++)
        dp[i][0][0] = 0;
    int ans = 0;
    for(int k=1; k&lt;=m; k++) {
        for(int i=1; i&lt;=n; i++) {
            int sum = 0;
            for(int j=0; j&lt;=i; j++) {//注意j从0开始，一开始从1开始WA了好久
                sum += a[i][j];
                for(int p=j-1; p&lt;=i-1; p++)
                    if(k &gt;= j &amp;&amp; p &gt;= 0 &amp;&amp; dp[i-1][p][k-j] != -1)
                        dp[i][j][k] = max(dp[i][j][k], sum+dp[i-1][p][k-j]);
                ans = max(ans, dp[i][j][k]);
            }
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/tyvj 1505 打砖头 /" data-id="cjttuf880002we8v3ytxv4g7g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-poj 3071 【概率dp】 " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/poj 3071 【概率dp】 /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/poj 3071 【概率dp】 /">poj 3071 【概率dp】</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>题目链接： <a href="http://poj.org/problem?id=3071" target="_blank" rel="noopener"> poj 3071 Football </a>  </p>
<p>题意：有2^n只足球队，已知你两两足球队间的胜率p[i][j]（足球队i赢足球队j的概率），赛制为单轮淘汰制并且每轮中剩余队伍序号1与2对战，3与4对战，5<br>与6对战…问n轮过后哪只足球队的胜率最大。</p>
<p>题解：设dp[i][j]为第i轮第j只队伍获胜的概率，</p>
<p>转移方程如下：</p>
<p>dp[i][j] += dp[i-1][j]<em>p[j][k]</em>dp[i-1][k]</p>
<p>k为第i轮可能与j对战的球队</p>
<p>这里k与i和j是存在关系的，可以写下可能的对战序列进行观察，这里取八只队伍：</p>
<p>第一轮 1:(2) 2:(1) 3:(4) 4:(3) 5:(6) 6:(5) 7:(8) 8:(7)  </p>
<p>第二轮 1:(3,4) 2:(3,4) 3:(1,2) 4:(1,2) 5:(7,8) 6:(7,8) 7:(5,6) 8:(5,6)</p>
<p>第三轮 1:(5,6,7,8) 2:(5,6,7,8) 3:(5,6,7,8) 4:(5,6,7,8) 5:(1,2,3,4) 6:(1,2,3,4)<br>7:(1,2,3,4) 8:(1,2,3,4)</p>
<p>从上面就可以找到规律确定k的范围</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;time.h&gt;
#include&lt;sstream&gt;

using namespace std;
#define MAX_N 100005
#define inf 0x3f3f3f3f
#define LL long  long
#define ull unsigned long long
const LL INF = 1e18;
const double eps = 1e-8;
//const int mod = 1e9+7;
//const double pi = acos(-1);
typedef pair&lt;int, int&gt;P;

double p[1&lt;&lt;8][1&lt;&lt;8];
double dp[10][1&lt;&lt;8];
int pow2(int k)
{
    int ans = 1;
    while(k) {
        k--;
        ans *= 2;
    }
    return ans;
}
int cal(int a, int b)
{
    return (b/a)+1;
}
int main()
{
    int n;
    while(cin &gt;&gt; n &amp;&amp; n!=-1) {
        for(int i=0; i&lt;(1&lt;&lt;n); i++)
            for(int j=0; j&lt;(1&lt;&lt;n); j++)
                scanf(&quot;%lf&quot;, &amp;p[i][j]);
        memset(dp, 0, sizeof(dp));
        for(int i=0; i&lt;(1&lt;&lt;n); i++)
            dp[0][i] = 1;
        for(int i=1; i&lt;=n; i++) {
            for(int j=0; j&lt;(1&lt;&lt;n); j++) {
                int m = pow2(i-1);
                int pos = cal(2*m, j);
                int mid = (2*pos-1)*m;
                int s, e;
                if(j &lt; mid) {
                    s = mid;
                    e = pos*m*2;
                }
                else {
                    s = (pos-1)*m*2;
                    e = mid;
                }
                //printf(&quot;%d %d %d %d\n&quot;, i, j, s, e);
                for(int k=s; k&lt;e; k++) {
                    dp[i][j] += dp[i-1][j]*p[j][k]*dp[i-1][k];
                }
            }
            //puts(&quot;&quot;);
        }
        int idx = 0;
        for(int i=0; i&lt;(1&lt;&lt;n); i++) {
            //printf(&quot;%.3lf &quot;, dp[n][i]);
            if(dp[n][i] &gt; dp[n][idx])
                idx = i;
        }
        //puts(&quot;&quot;);
        cout &lt;&lt; idx+1 &lt;&lt; endl;
    }
}
</code></pre><p>代码写的略渣了点。。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/poj 3071 【概率dp】 /" data-id="cjttuf878001xe8v3ueuaejd1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-poj 3295 Tautology " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/poj 3295 Tautology /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/poj 3295 Tautology /">poj 3295 Tautology</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>链接：<a href="http://poj.org/problem?id=3295" target="_blank" rel="noopener">http://poj.org/problem?id=3295</a></p>
<p>模拟了一下：</p>
<pre><code>#include&lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;time.h&gt;
using namespace std;
#define MAX_N 105
#define inf 0x7fffffff
#define LL long long
#define ull unsigned long long
const LL INF = 9e18;
const int mod = 100000000;
typedef pair&lt;double, double&gt;P;

char S[MAX_N];
stack&lt;char&gt;ope, c;
map&lt;char, int&gt;mp;
int p, q, r, s, t;
int len;
void init()
{
    mp[&apos;p&apos;] = p;
    mp[&apos;q&apos;] = q;
    mp[&apos;r&apos;] = r;
    mp[&apos;s&apos;] = s;
    mp[&apos;t&apos;] = t;
}
int find(int left, int right)
{
    if(S[left]&gt;=&apos;a&apos; &amp;&amp; S[left]&lt;=&apos;z&apos;)
        return left;
    int sum;
    if(S[left] == &apos;N&apos;)
        sum = 1;
    else
        sum = 2;
    for(int i=left+1;i&lt;=right;i++) {
        if(S[i]&gt;=&apos;a&apos; &amp;&amp; S[i]&lt;=&apos;z&apos;)
            sum--;
        else if(S[i]!=&apos;N&apos;)
            sum++;
        if(!sum)
            return i;
    }
    return right;
}
bool dfs(int left, int right)
{
    if(right == left) {
        return mp[S[left]];
    }
    if(S[left] == &apos;N&apos;) {
        return !dfs(left+1, right);
    }
    else {
        if(S[left] &lt;= &apos;z&apos; &amp;&amp; S[left] &gt;= &apos;a&apos;) {
            return mp[S[left]];
        }
        else if(S[left] == &apos;K&apos;) {
            int mid = find(left+1, right);
            return dfs(left+1, mid) &amp; dfs(mid+1, right);
        }
        else if(S[left] == &apos;A&apos;) {
            int mid = find(left+1, right);
            return dfs(left+1, mid) | dfs(mid+1, right);
        }
        else if(S[left] == &apos;C&apos;) {
            int mid = find(left+1, right);
            return (!dfs(left+1, mid)) | dfs(mid+1, right);
        }
        else if(S[left] == &apos;E&apos;) {
            int mid = find(left+1, right);
            return dfs(left+1, mid) == dfs(mid+1, right);
        }
    }
}
bool check()
{
    for(p=0;p&lt;2;p++) {
        for(q=0;q&lt;2;q++) {
            for(r=0;r&lt;2;r++) {
                for(s=0;s&lt;2;s++) {
                    for(t=0;t&lt;2;t++) {
                        init();
                        if(!dfs(0, len-1)) {
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}
int main()
{
    while(scanf(&quot;%s&quot;,S)) {
        if(S[0] == &apos;0&apos;)
            break;
        len = strlen(S);
        if(check())
            printf(&quot;tautology\n&quot;);
        else
            printf(&quot;not\n&quot;);
    }
}
</code></pre><p>评论区里看到的一个简洁递归：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cassert&gt;

using namespace std;

string s;int cur;char a[5];

void Change(char i)//穷举时改变数组用的函数
{
    for(int j=0;j!=5;j++)
        a[j]=((i&gt;&gt;j)&amp;00000001);
}
bool Cal()//递归
{
    char c=s[cur];bool w,x;
    cur++;
    switch(c){
    case &apos;p&apos;:return a[0];
    case &apos;q&apos;:return a[1];
    case &apos;r&apos;:return a[2];
    case &apos;s&apos;:return a[3];
    case &apos;t&apos;:return a[4];
    case &apos;N&apos;:return !Cal();
    case &apos;K&apos;:w=Cal();x=Cal();return (w&amp;&amp;x);
    case &apos;A&apos;:w=Cal();x=Cal();return (w||x);
    case &apos;C&apos;:w=Cal();x=Cal();return (w&lt;=x);
    case &apos;E&apos;:w=Cal();x=Cal();return (w==x);
    default :return 0;
    }
}
int main()
{
    int f;
    while(1)
    {
        cin&gt;&gt;s;
        if(s==&quot;0&quot;)  break;
        f=1;
        for(char i=0;i!=32;i++)
        {
            cur=0;Change(i);
            if(!Cal()) {f=0;break;}
        }
        if(f==1) cout&lt;&lt;&quot;tautology&quot;&lt;&lt;endl;
        else cout&lt;&lt;&quot;not&quot;&lt;&lt;endl;

    }
    return 0;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/poj 3295 Tautology /" data-id="cjttuf87a0021e8v3j6rx2lgn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-21位 花朵数 " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/21位 花朵数 /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/21位 花朵数 /">21位 花朵数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>题意：</p>
<p>一个N位的十进制正整数，如果它的每个位上的数字的N次方的和等于这个数本身，则称其为花朵数。</p>
<p>例如：当N=3时，153就满足条件，因为 1^3 + 5^3 + 3^3 =<br>153，这样的数字也被称为水仙花数（其中，“^”表示乘方，5^3表示5的3次方，也就是立方）。</p>
<p>当N=4时，1634满足条件，因为 1^4 + 6^4 + 3^4 + 4^4 = 1634。</p>
<p>当N=5时，92727满足条件。</p>
<p>实际上，对N的每个取值，可能有多个数字满足条件。</p>
<p>程序的任务是：求N=21时，所有满足条件的花朵数。注意：这个整数有21位，它的各个位数字的21次方之和正好等于这个数本身。</p>
<p>如果满足条件的数字不只有一个，请从小到大输出所有符合条件的数字，每个数字占一行。因为这个数字很大，请注意解法时间上的可行性。要求程序在1分钟内运行完毕。</p>
<p>题解：</p>
<p>看了网上的思路，大概是枚举每个数出现的次数，其中次数和不超过21次，然后因为不管怎么排列，数字对应出现次数最终求和都为同一个值，所以可以判断最终生成的数中各<br>数字出现的次数与枚举的是否相同即可。深搜剪枝后数字出现次数符合的仅有14307150个，6s就可以得到答案</p>
<pre><code>#include&lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;time.h&gt;
using namespace std;
#define MAX_N 100005
#define inf 0x7fffffff
#define LL long long
#define ull unsigned long long
const LL INF = 9e18;
const int mod = 100000000;

int x[10];
int num[10][3];
void init()
{
    num[0][2] = 0;        num[0][1] = 0;        num[0][0] = 0;
    num[1][2] = 0;        num[1][1] = 0;        num[1][0] = 1;
    num[2][2] = 0;        num[2][1] = 0;        num[2][0] = 2097152;
    num[3][2] = 0;        num[3][1] = 104;      num[3][0] = 60353203;
    num[4][2] = 0;        num[4][1] = 43980;    num[4][0] = 46511104;
    num[5][2] = 0;        num[5][1] = 4768371;  num[5][0] = 58203125;
    num[6][2] = 2;        num[6][1] = 19369506; num[6][0] = 40377856;
    num[7][2] = 55;       num[7][1] = 85458640; num[7][0] = 83284007;
    num[8][2] = 922;      num[8][1] = 33720368; num[8][0] = 54775808;
    num[9][2] = 10941;    num[9][1] = 89891315; num[9][0] = 12359209;
}
void check()
{
    int tmp[3];
    memset(tmp, 0, sizeof(tmp));
    for(int i=0;i&lt;10;i++) {
        tmp[0] = tmp[0] + (num[i][0]*x[i]);
        tmp[1] = tmp[1] + (num[i][1]*x[i]);
        tmp[2] = tmp[2] + (num[i][2]*x[i]);

        tmp[1] = tmp[1] + (tmp[0]/mod);
        tmp[0] = tmp[0] % mod;

        tmp[2] = tmp[2] + (tmp[1]/mod);
        tmp[1] = tmp[1] % mod;
    }
    int sum[10];
    memset(sum, 0, sizeof(sum));
    int t = tmp[2];
    int dd = 0;
    while(t) {
        sum[t%10]++;
        t/=10;
        dd++;
    }
    t = tmp[1];
    while(t) {
        sum[t%10]++;
        t/=10;
        dd++;
    }
    t = tmp[0];
    while(t) {
        sum[t%10]++;
        t/=10;
        dd++;
    }
    sum[0] += 21 - dd;
    for(int i=0;i&lt;=9;i++)
        if(sum[i] != x[i])
            return ;
    if(!tmp[2] || !tmp[1] || !tmp[0])
        return ;
    printf(&quot;%d%d%d\n&quot;,tmp[2],tmp[1],tmp[0]);
}
int sum = 0;
void dfs(int k, int total)
{
    if(total &gt; 21)
        return;
    if(k == -1) {
        if(total == 21)
            check(),sum++;
        return;
    }
    for(int i=21;i&gt;=0;i--) {
        x[k] = i;
        dfs(k-1, total+i);
    }
}
int main()
{
    init();
    dfs(9, 0);
    cout &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/21位 花朵数 /" data-id="cjttuf8630003e8v3osbf4u7k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-tyoj 1059 过河【压缩】 " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/tyoj 1059 过河【压缩】 /" class="article-date">
  <time datetime="2017-06-21T04:00:00.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/acm/">acm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/tyoj 1059 过河【压缩】 /">tyoj 1059 过河【压缩】</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>题目链接：</p>
<p><a href="http://www.tyvj.cn/p/1059" target="_blank" rel="noopener">http://www.tyvj.cn/p/1059</a></p>
<p>题解：</p>
<p>当L较小时有,dp[i] = dp[i-j] + (位置i是否为石头)，（dp[i] = 跳至距离为i时最少跳几个石头）</p>
<p>但是此题L较大，但是S，T，M较小，所以我们可以将两块较长距离的石头间的距离压缩，比如d &gt; 200（d为两块石头间的距离）可以视作 d = 200，因为<br>S，T均小于10，当 d = 200 时与d &gt; 200所能到达点的可能性相同。（不一定要取200，最小取到s*t，具体证明：<a href="http://blog.csd" target="_blank" rel="noopener">http://blog.csd</a><br>n.net/wdlsjdl2/article/details/51282795）。然后再注意S==T时的情况。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;time.h&gt;
using namespace std;
#define MAX_N 100005
#define inf 0x3f3f3f3f
#define LL long long
#define ull unsigned long long
const LL INF = 1e18;
const int mod = 1e8+7;
typedef pair&lt;int, int&gt;P;

int L, S, T, M;
int dp[205*105+5];
bool st[205*105+5];
int a[105];
int main()
{
    cin &gt;&gt; L &gt;&gt; S &gt;&gt; T &gt;&gt; M;
    for(int i=1; i&lt;=M; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    a[0] = 0;
    a[M+1] = L;
    sort(a, a+M+2);
    if(S == T) {
        int ans = 0;
        for(int i=1; i&lt;=M; i++)
            if(a[i]%S == 0)
                ans++;
        cout &lt;&lt; ans &lt;&lt; endl;
        return 0;
    }
    for(int i=1; i&lt;=M+1; i++) {
        if(a[i]-a[i-1]&lt;200)
            continue;
        int d = a[i] - a[i-1] - 200;
        for(int j=i; j&lt;=M+1; j++) {
            a[j] -= d;
        }
    }
    memset(dp, inf, sizeof(dp));
    memset(st, false, sizeof(st));
    dp[0] = 0;
    for(int i=1; i&lt;=M; i++)
        st[a[i]] = true;
    for(int i=1; i&lt;=a[M+1]+T; i++)
        for(int j=S; j&lt;=T; j++)
            if(i-j &gt;= 0)
                dp[i] = min(dp[i], dp[i-j] + st[i]);
    int ans = inf;
    for(int i=a[M+1]; i&lt;=a[M+1]+T; i++)
        ans = min(ans, dp[i]);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://t51645.github.io/2017/06/21/tyoj 1059 过河【压缩】 /" data-id="cjttuf87c0025e8v3v7egd6ex" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/acm/">acm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/搭建博客/">搭建博客</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/教程/" style="font-size: 10px;">教程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/29/模拟登陆ZJJCXY/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/29/test/">test</a>
          </li>
        
          <li>
            <a href="/2019/03/29/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/06/21/codeforces 767B The Queue【贪心】 /">codeforces 767B The Queue【贪心】</a>
          </li>
        
          <li>
            <a href="/2017/06/21/Codeforces Round #418 (Div. 2) C. An impassioned circulation of affection/">Codeforces Round</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>